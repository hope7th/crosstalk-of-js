function Car() {
    this.name = "Car";
    this.color = "Red";
}

var x = new Car();
console.log(x)

/**
 * 在 JavaScript 1.0 的时候，对象是不支持继承的。那时的 JavaScript 使用的是称为“类抄写”的技术来创建对象，
 */

/**
 * 对象是零到多个的属性的集合。
 */

/**
 * 从而将从 JavaScript 1.1 才开始具有的原型继承作为它最主要的面向对象特征。
 */

/**
 * 向没有声明的变量名赋值，会隐式地创建一个全局变量；
 * 全局变量会被绑定为全局对象（global）的属性 。
 */

x = "ss"
console.log(x)

/**
 * 由于 JavaScript 也实现了带有闭包性质的函数，因此“闭包”也成了环境的管理组件。
 * 也就是说，闭包与对象都具有实现变量环境的能力
 * JavaScript 提出了“对象闭包”与“函数闭包”两个概念，并把它们用来实现的环境称为“域（Scope）”。
 */
scope = {
    object: '<创建本闭包的对象或函数>',
    parent: '<父级的scope>'
}

/***
 * 尽管在静态语法说明或描述时，它们被称为作用域或域（Scope），
 * 或者在动态环境中它们被称为上下文（Context），但在本质上，它们是同样的一堆东西。
 */

/**
 * JavaScript 中的对象本质上是属性集，
 * 这可以视为一个键值列表，而对象继承是由这样的列表构成的、称为原型的链。
 * 另一方面，执行的上下文就是函数或全局的变量表，
 * 这同样可以表达为一个键值列表，而执行环境也可以视为一个由该键值列表构成的链。
 * 这门语言仅仅依赖键值列表和基于它们的链实现并完善了它最初的设计。
 */


/**
 * 属性访问与可见性
 * “一个属性是否能用 for…in 语句列举出来”。
 * 如果它可以被列举，那么就是可见的，否则就称为隐藏的。
 * 任何对象都有“constructor”这个属性，缺省指向创建它的构造器函数，并且它应当是隐藏的属性
 * “属性的性质（attributes）”这样的东西，也就是我们现在知道的可写性、可列举性（可见性）和可配置性。
 * “constructor”缺省是一个不可列举的属性；
 * 使用赋值表达式添加属性时，属性的可列举性缺省为true。
 */

/**
 * 从原型中继承来的属性
 * 在原型继承中，在子类实例重写属性时，实际发生的行为是“在子类实例的自有属性表中添加一个新项”。
 * 这并不改变原型中相同属性名的值，但子类实例中的属性性质以及值覆盖了原型中的。
 * 1,如果是数据描述符（d），那么d.value总是指向这个数据的值本身；
 * 2,如果是存取描述符，那么d.get()和d.set()将分别指向属性的存取方法。
 */

var excel = Object.defineProperty(new Object, "Exit", {
    get() {
        return "100"
    }
});

var excel2 = new Object();
excel2.Exit = "200";

console.log(excel.Exit);
console.log(excel2.Exit);
/**
 * 如果是存取描述符，那么存取方法（get/setter）并不一定关联到数据，
 * 也并不一定是数据的置值或取值
 */

/**
 * 所谓“包装类”是 JavaScript 从 Java 借鉴来的特性之一
 * 它使得用户代码可以用标准的面向对象方法来访问普通的值类型数据。
 * 于是，所谓“一切都是对象
 */

 var x2 = "abc";
 console.log(x2.toString())
 console.log(Object(x2));
 console.log(Object(x2).toString())

 /**
  * 这个包装的过程发生于函数调用运算“( )”的处理过程中，或者将“x.toString”作为整体来处理的过程中。
  * 也就是说，仅仅是“对象属性存取”这个行为本身，并不会触发一个普通“值类型数据”向它的包装类型转换。
  * 基本类型中的所有值类型数据都有自己的包装类，包括符号，又或者布尔值。
  * 这使得这些值类型的数据也可以具有与之对应的包装类的原型属性或方法。这些属性与方法自己引用自原型，而不是自有数据
  */


 // 字面量与标识符
  var x = 1;
//   console.log(1.toString()) //是浮点数的表示法。所以“1.toString”这样的语法在 JavaScript 中会报错，
  console.log(x.toString())
  console.log(1..toString()) //在 JavaScript 中，浮点数的小位数是可以为空的，因此“1.”和“1.0”将作为相同的浮点数被解析出来。

  console.log(1 in 1..constructor)
  console.log(1 in Object(1.0).constructor)
  Number[1] = true; //修改原型链中的对象
  console.log(1 in 1..constructor)

/**
 * x = new Number(1.0);
 * 而“x.constructor”不是自有属性，由于 x 是“Number()”这个类 / 构造器的子类实例，
 * 因此该属性实际继承自原型链上的“Number.prototype.construtcotr”这个属性。
 * 然后，在缺省情况下，“aFunction.prototype.construtcotr”指向这个函数自身。
 * 也就是说，“Number.prototype.construtctor”与“1…constructor”相同，且都指向 Number() 自身。
 */

 
 /**
  * 德云社刚成立的时候，郭德纲和于谦没有孩子，他们找合伙人的方式就是：说学逗唱基本功。
  * 后来他们挣钱娶媳妇了，要生孩子了
  * 于麒麟和郭小宝说：你让我当班主啊，于是，他们还集成了爸爸的属性。
  * 郭麒麟和岳云鹏打架，打不过就找爸爸。相二代就是这么横。
  * 相二代学习相声，有两条，一是自己学，数据描述符（d），而是师父教，存取描述符，d.get()和d.set()
  * 任何对象，都可以调用原型类的方法，但是，特殊情况会调错，比如，于谦的年龄是44.5岁，44.的时候，变会被处理成浮点数
  * 所以不能调属性。如果需要改属性，需要改于谦年龄原型链上的属性。
  */