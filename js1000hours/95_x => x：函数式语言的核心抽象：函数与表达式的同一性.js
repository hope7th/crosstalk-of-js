//函数就是具有[[Call]]私有槽的对象”
//语句执行是命令式范型的体现，而函数执行代表了 JavaScript 中对函数式范型的理解

/**
 * 静态的视角来看函数，它就是一个函数对象（函数的实例），用三个语义组件构成的实体，
 * 参数，执行体，结果，
 */

function f() {
    //...
}

// 当我们把这三个部分构成的一个整体看作执行体的时候：函数表达式
(function () {})() //立即执行函数 //函数既是可以执行的逻辑，也同时是可以被逻辑处理的数据

/** 函数作为数据时，它是原始函数声明的一个实例，
 *  注意这里并不强调它是对象实例，
 *  这个实例必须包括上述三个语义组件中的两个，既参数和执行体
 */

var arr = new Array;
for (var i = 0; i < 5; i++)
    arr.push(function f() {})
console.log(arr);
console.log(arr[0] == arr[1]);

/**
 * 上面说过，这样的闭包有两个语义组件：参数和执行体。
 * 在创建这个闭包时，它们也将同时被实例化。
 * 用户的代码引用一次这样的函数，就会拿到该函数的一个闭包。
 */

/**
 * 函数体和 for 的循环体（这些用来实现逻辑复用的执行结构）的创建技术，是完全一样的！
 * 。只不过前者把它叫做 _iteratorEnv_，是 _loopEnv_ 的实例；
 * 后者把它叫做闭包，是函数的实例。
 */

/**
 * 参数x执行体x在闭包创建时，参数 x 将作为闭包（作用域 / 环境）
 * 中的名字被初始化——这个过程中“参数 x”只作为名字或标识符，
 * 并且“将会在”闭包中登记一个名为“x”的变量；
 */

(x = x) => x;
/**
 * 凡是在参数声明中使用了缺省参数、
 * 剩余参数和模板参数之一的，都不再是“简单的”.
 * 在使用传统的简单参数时，只需要将调用该参数时传入的实际参数与参数对象（arguments）绑定就可以了；
 * 而使用“非简单参数”时，需要通过“初始器赋值”来完成名字与值的绑定。
 * 通常将实际参数与参数对象绑定时，只需要映射两个数组的下标即可，
 * 而“初始器赋值”需要通过名字来索引值（以实现绑定），因此一旦出现“重名参数”就无法处理了。
 */

function f(x) {
    console.log(x);
}

f(a1 = 100)
console.log(a1) //100
/**
 * JavaScript 的函数是“非惰性求值”的，也就是说在函数界面上不会传入一个延迟计算的求值过程，而是“积极地”传入已经求值的结果
 * a = 100这行表达式执行在哪个上下文环境中呢？
 * 在函数外（上例中是全局环境）
 */

function f1(x1) {
    console.log(x1);
    var x1 = 200;
}
f1(100)
// console.log(x1)

function f00(x2 = 100) {
    console.log(x2)
}
f00()
//  console.log(x2) //x2 is not defined
/**
 * 不同于之前的f(a = 100)，在这里的表达式x = 100将执行于这个新创建的闭包中。
 * 这很好理解，左侧的“参数 x”是闭包中的一个语法组件，是初始化创建在闭包中的一个变量声明，
 */
var f2 = (x3 = x3) => x3;
// f2() //x3 is not defined

function foo2() {
    console.log(x); // ReferenceError: x is not defined 
    let x = 100;
};
// foo2(); x is not defined

/**
 * 由于 let 变量不能在它的声明语句之前（亦即是未初始化之前）访问，
 * 因此上例触发了与之前的箭头函数f()完全相同的异常
 */

 /**
  * 无论对于 var/let 来说，一开始的时候它们其实都是“无初值的绑定”。
  * 只不过 JavaScript 在处理 var 语句声明的变量时，将这个“绑定（Binding）”赋了一个初值undefined，
  * 因此你才可以在代码中自由、提前地访问那些“var 变量”。而对应的，let 语句声明的变量没有“缺省地”赋这个初值，所以才不能在第一行赋值语句之前访问它
  */

 //let x = x; //ReferenceError: x is not defined
  /**
   * 为什么不干脆就在“初始器”创建的时候，就赋一个初值 undefined 呢？说到这里，可能你也猜到了，
   * 因为在“缺省参数”的语法设计里面，undefined 正好是一个有意义的值，它用于表明参数表指定位置上的形式参数是否有传入，
   * 所以参数 undefined 也就不能作为初值来绑定，这就导致了使用“初始器”的参数表中，所对应那些变量是一个“无初值的绑定”。
   */

   /**
    * 郭德纲每次演出的时候都有一份名单，有确切的几场，有两个人，先占好名额。主持人可以报名字
    * 也有少数林场变故，不确定谁上谁不上，就不确定名额。不确定名额的不能上报名字，
    * 
    */
