// 最受欢迎的JS 引擎是V8，由 Google Chrome 和 Node.js使用，SpiderMonkey 用于Firefox，以及Safari/WebKit使用的 JavaScriptCore。
var num = 2;

function pow(num) {
    return num * num;
}

/* 1: js栈内存和堆内存的区别
首先JavaScript中的变量分为基本类型和引用类型。基本类型就是保存在栈内存中的简单数据段，而引用类型指的是那些保存在堆内存中的对象。
1、基本类型
 基本类型有Undefined、Null、Boolean、Number 和String。这些类型在内存中分别占有固定大小的空间，他们的值保存在栈空间，我们通过按值来访问的。   
2、引用类型
引用类型，值大小不固定，栈内存中存放地址指向堆内存中的对象。是按引用访问的。如下图所示：栈内存中存放的只是该对象的访问地址，在堆内存中为这个值分配空间。由于这种值的大小不固定，因此不能把它们保存到栈内存中。但内存地址大小的固定的，因此可以将内存地址保存在栈内存中。 这样，当查询引用类型的变量时， 先从栈中读取内存地址， 然后再通过地址找到堆中的值。对于这种，我们把它叫做按引用访问当我们看到一个变量类型是已知的，就分配在栈里面，比如INT,Double等。其他未知的类型，比如自定义的类型，因为系统不知道需要多大，所以程序自己申请，这样就分配在堆里面。基本类型大小固定，引用类型大小不固定，分开存放使得程序运行占用内存最小。
3、栈内存：存放基本类型。 堆内存：存放引用类型（在栈内存中存一个基本类型值保存对象在堆内存中的地址，用于引用这个对象。）
4、基本类型在当前执行环境结束时销毁，而引用类型不会随执行环境结束而销毁，只有当所有引用它的变量不存在时这个对象才被垃圾回收机制回收。

比喻：栈里面都是同学的名字，按顺序排列，堆里都是同学杂乱无章的任务，你和老师要共同完成今天的任务
*/





/* 2: js 为什么是单线程的 
比喻：你和同桌小溪同时抢一块橡皮，老师是不是很头疼
*/


/* 3: js JS为什么需要异步?
比喻：同学临时内急，需要上厕所，在等待时间内，其他同学可以按顺序完成认为
*/

/* 4:js中的时间循环 代码如下

首先判断JS是同步还是异步,同步就进入主线程（事件队列）,异步就进入event table(事件表))
异步任务在event table中注册函数,当满足触发条件后,被推入event queue
同步任务进入主线程后一直执行,直到主线程空闲时,才会去event queue中查看是否有可执行的异步任务,如果有就推入主线程中

比喻：同学是同步任务就放在事件队列里立即执行，异步任务就给他一块计时器，计时结束放在事件队列里就执行，老师每次都检查事件队列是不是空的
*/
var s = 0;
s
console.log(1)
setTimeout(() => {
    console.log(2)
}, 0);
console.log(3)
//  1 3 2

setTimeout(() => {
    console.log("定时器开始啦")
}, 0);

new Promise(function(resolve){
    console.log("马上执行for循环啦")
    for(var i=0;i<10000;i++){
        i==99&&resolve()
    }
}).then(function(){
    console.log("执行then函数啦")
})
console.log("代码执行结束啦")

/*首先执行script下的宏任务,遇到setTimeout,将其放到宏任务的【队列】里

遇到 new Promise直接执行,打印"马上执行for循环啦"

遇到then方法,是微任务,将其放到微任务的【队列里】

打印 "代码执行结束"

本轮宏任务执行完毕,查看本轮的微任务,发现有一个then方法里的函数, 打印"执行then函数啦"

到此,本轮的event loop 全部完成。


下一轮的循环里,先执行一个宏任务,发现宏任务的【队列】里有一个 setTimeout里的函数,执行打印"定时器开始啦"


比喻：报名上厕所的同学，即使没去厕所，也会等老师空闲了才放入事件列表中，而其他可能异步的同学则直接放入到事件列表中，所以还是报名上厕所的最晚。
*/
 




