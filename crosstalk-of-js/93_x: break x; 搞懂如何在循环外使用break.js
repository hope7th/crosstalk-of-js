/**
 * 第一种中断，
 * 所谓“可中断语句”其实只有两种，包括全部的循环语句，以及 swtich 语句。
 * 在这两种语句内部使用的“break;”，
 * 采用的就是这种处理机制——中断当前语句，将执行逻辑交到下一语句。
 */


/**
 * 第二种中断
 * 所谓标签化语句，就是在一般语句之前加上“xxx:”这样的标签，用以指示该语句
 * // 标签
 * aaaaaa: { ...}
 * // 标符
 * bbbbbb: if (true) { ...}
 */

var i = 100;

function foo() {
    bbb: try {
        console.log("Hi")
        return i++
    }
    finally {
        break bbb;
    }
    console.log("Here");
    return i;
}
console.log(foo())

// 你的预期可能会是“位置 1”返回的 100，而事实上将执行到输出“Here”并通过位置 2 返回 101。
// 这也很好地说明了 **break语句本质上就是作用于其后的“一个语句”，而与它“有多少个块级作用域”无关 **。

console.log(eval(`
aaa1: {
    1+2;
    bbb1:{3+4;break aaa1;}
}`)); // 7

/**
 * 标签化语句 bbb 将首先捕获到这个语句完成状态，并携带有标签 aaa；
 * 由于 bbb 语句完成时检查到的状态中的中断目标（Target）与自己的标签不同，
 * 所以它将这个状态继续作为自己的完成状态，返回给外层的 aaa 标签化语句 aaa；
 * 语句 aaa 得到上述状态，并对比标签成功，返回结果为语句3+4的值（作为完成状态传出）。
 */

console.log(eval(`
aaa1: {
    1+2;
    bbb1:{3+4;break bbb1;}
}`)); // 7
// 爸爸教育孩子，每人发一张打断卡，打断以后，家里必须换话题。打断卡每天只能使用一次。